/**
 * @fileoverview Schema generation with RLS support
 * 
 * Generates PostgREST-compatible database schemas with Row Level Security,
 * proper roles, and optimized for PostgREST usage patterns.
 * 
 * @author PGRestify Team
 * @since 2.0.0
 */

import { Command } from 'commander';
import chalk from 'chalk';
import inquirer from 'inquirer';
import path from 'path';
import { logger } from '../../../utils/logger.js';
import { fs } from '../../../utils/fs.js';
import { writeTableSQL, SQL_FILE_TYPES, createTableFolderStructure, getCommandString } from '../../../utils/sql-structure.js';
import { getHashService } from '../../../utils/hash-service.js';
import { getPostgRESTConfig, generateGrantStatement } from '../../../utils/postgrest-config.js';

/**
 * Create schema generate command
 */
export function createGenerateCommand(): Command {
  const command = new Command('generate');
  
  command
    .description('Generate PostgREST schema with RLS (table-based folder structure)')
    .option('--with-rls', 'Include Row Level Security policies', true)
    .option('--with-functions', 'Include utility functions', true)
    .option('--with-triggers', 'Include audit triggers', true)
    .option('--schema <name>', 'Schema name')
    .option('--tables <tables>', 'Comma-separated table names')
    .option('--single-file', 'Deprecated: Use single file mode (not recommended)')
    .action(async (options) => {
      await generateSchema(options);
    });
  
  return command;
}

/**
 * Generate PostgREST schema
 */
async function generateSchema(options: any) {
  logger.info(chalk.cyan('🗄️  Generating PostgREST Schema with RLS'));
  logger.newLine();
  
  // Get PostgREST configuration
  const postgrestConfig = await getPostgRESTConfig();
  
  // Collect schema configuration
  const config = await collectSchemaConfig(options, postgrestConfig);
  
  // Always use table-folder structure (mandatory)
  if (options.singleFile) {
    logger.warn(chalk.yellow('⚠️  Single file mode is deprecated. Using table-folder structure instead.'));
    logger.info(chalk.gray('📁 Table-folder structure provides better organization and maintainability.'));
  }
  
  await generateSchemaInFolders(config);
}

/**
 * Collect schema configuration
 */
async function collectSchemaConfig(options: any, postgrestConfig: any) {
  const config = {
    schema: options.schema || postgrestConfig.schema,
    output: options.output,
    withRLS: options.withRls,
    withFunctions: options.withFunctions,
    withTriggers: options.withTriggers,
    tables: options.tables ? options.tables.split(',').map(t => t.trim()) : [],
    anonRole: postgrestConfig.anonRole,
    jwtSecret: postgrestConfig.jwtSecret,
    serverHost: postgrestConfig.serverHost,
    serverPort: postgrestConfig.serverPort,
    preRequest: postgrestConfig.preRequest
  };
  
  // If no tables specified, ask for them
  if (config.tables.length === 0) {
    const { tables } = await inquirer.prompt([
      {
        type: 'input',
        name: 'tables',
        message: 'Enter table names (comma-separated):',
        default: 'users, posts, comments',
        validate: (input) => input.trim().length > 0 || 'At least one table name is required'
      }
    ]);
    
    config.tables = tables.split(',').map(t => t.trim());
  }
  
  return config;
}

/**
 * Generate complete schema SQL
 */
function generateCompleteSchema(config: any): string {
  const parts = [
    generateHeader(config),
    generateExtensions(),
    generateSchemaSQL(config),
    generateRoles(config),
    generateTables(config),
    config.withRLS ? generateRLSPolicies(config) : '',
    config.withFunctions ? generateUtilityFunctions(config) : '',
    config.withTriggers ? generateAuditTriggers(config) : '',
    generatePermissions(config),
    generateFooter()
  ];
  
  return parts.filter(Boolean).join('\n\n');
}

/**
 * Generate SQL header
 */
function generateHeader(config: any): string {
  return `-- PostgREST Schema Generated by PGRestify
-- Generated: ${new Date().toISOString()}
-- Schema: ${config.schema}
-- RLS: ${config.withRLS ? 'Enabled' : 'Disabled'}
-- 
-- This schema is optimized for PostgREST usage with proper security.
-- 
-- Setup Instructions:
-- 1. Run this SQL against your PostgreSQL database
-- 2. Configure PostgREST to use schema "${config.schema}"
-- 3. Set up authentication with the generated roles
--
-- Security Notice:
-- - RLS policies are enabled for all tables
-- - Anonymous access is restricted by default
-- - Authenticated users have limited permissions`;
}

/**
 * Generate required extensions
 */
function generateExtensions(): string {
  return `-- Required extensions for PostgREST
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
CREATE EXTENSION IF NOT EXISTS "pgjwt";`;
}

/**
 * Generate schema creation SQL
 */
function generateSchemaSQL(config: any): string {
  return `-- Create API schema
CREATE SCHEMA IF NOT EXISTS ${config.schema};`;
}

/**
 * Generate PostgREST roles
 */
function generateRoles(config: any): string {
  const anonRole = config.anonRole;
  const authRole = 'authenticated'; // Standard PostgREST authenticated role
  
  return `-- PostgREST roles
CREATE ROLE ${anonRole} NOLOGIN;
CREATE ROLE ${authRole} NOLOGIN;
CREATE ROLE authenticator NOINHERIT LOGIN;

-- Grant role memberships
GRANT ${anonRole} TO authenticator;
GRANT ${authRole} TO authenticator;

-- Set search path for API schema
ALTER ROLE ${anonRole} SET search_path = ${config.schema}, public;
ALTER ROLE ${authRole} SET search_path = ${config.schema}, public;`;
}

/**
 * Generate table schemas
 */
function generateTables(config: any): string {
  const tables = config.tables.map(tableName => generateTable(tableName, config)).join('\n\n');
  return `-- Tables\n${tables}`;
}

/**
 * Generate individual table
 */
function generateTable(tableName: string, config: any): string {
  const cleanName = tableName.toLowerCase().replace(/[^a-z0-9_]/g, '_');
  
  // Generate basic table structure
  let sql = `CREATE TABLE ${config.schema}.${cleanName} (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()`;
  
  // Add table-specific columns based on common patterns
  if (cleanName.includes('user')) {
    sql += `,
  email TEXT UNIQUE NOT NULL,
  name TEXT NOT NULL,
  avatar_url TEXT,
  role TEXT NOT NULL DEFAULT 'user' CHECK (role IN ('user', 'admin'))`;
  } else if (cleanName.includes('post')) {
    sql += `,
  title TEXT NOT NULL,
  content TEXT,
  author_id UUID REFERENCES ${config.schema}.users(id) ON DELETE CASCADE,
  published BOOLEAN NOT NULL DEFAULT false`;
  } else if (cleanName.includes('comment')) {
    sql += `,
  content TEXT NOT NULL,
  author_id UUID REFERENCES ${config.schema}.users(id) ON DELETE CASCADE,
  post_id UUID NOT NULL`;
  } else {
    sql += `,
  -- Add your columns here
  name TEXT NOT NULL`;
  }
  
  sql += '\n);';
  
  // Add indexes
  sql += `\n\n-- Indexes for ${cleanName}
CREATE INDEX idx_${cleanName}_created_at ON ${config.schema}.${cleanName}(created_at);
CREATE INDEX idx_${cleanName}_updated_at ON ${config.schema}.${cleanName}(updated_at);`;
  
  return sql;
}

/**
 * Generate RLS policies
 */
function generateRLSPolicies(config: any): string {
  const policies = config.tables.map(tableName => generateTableRLS(tableName, config)).join('\n\n');
  return `-- Row Level Security Policies
${policies}`;
}

/**
 * Generate RLS for individual table
 */
function generateTableRLS(tableName: string, config: any): string {
  const cleanName = tableName.toLowerCase().replace(/[^a-z0-9_]/g, '_');
  const anonRole = config.anonRole;
  const authRole = 'authenticated';
  
  return `-- RLS for ${cleanName}
ALTER TABLE ${config.schema}.${cleanName} ENABLE ROW LEVEL SECURITY;

-- Allow anonymous users to read public data
CREATE POLICY "${cleanName}_select_public" ON ${config.schema}.${cleanName}
  FOR SELECT TO ${anonRole}
  USING (true);

-- Allow authenticated users to insert their own data
CREATE POLICY "${cleanName}_insert_own" ON ${config.schema}.${cleanName}
  FOR INSERT TO ${authRole}
  WITH CHECK (true);

-- Allow users to update their own data
CREATE POLICY "${cleanName}_update_own" ON ${config.schema}.${cleanName}
  FOR UPDATE TO ${authRole}
  USING (true)
  WITH CHECK (true);

-- Allow users to delete their own data  
CREATE POLICY "${cleanName}_delete_own" ON ${config.schema}.${cleanName}
  FOR DELETE TO ${authRole}
  USING (true);`;
}

/**
 * Generate utility functions
 */
function generateUtilityFunctions(config: any): string {
  return `-- Utility Functions

-- Function to get current user ID from JWT
CREATE OR REPLACE FUNCTION ${config.schema}.current_user_id()
RETURNS UUID AS $$
  SELECT COALESCE(
    current_setting('request.jwt.claims', true)::json->>'sub',
    current_setting('request.jwt.claims', true)::json->>'user_id'
  )::UUID;
$$ LANGUAGE SQL STABLE;

-- Function to check if user is admin
CREATE OR REPLACE FUNCTION ${config.schema}.is_admin()
RETURNS BOOLEAN AS $$
  SELECT COALESCE(
    (current_setting('request.jwt.claims', true)::json->>'role') = 'admin',
    false
  );
$$ LANGUAGE SQL STABLE;

-- Function to update timestamp
CREATE OR REPLACE FUNCTION ${config.schema}.update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;`;
}

/**
 * Generate audit triggers
 */
function generateAuditTriggers(config: any): string {
  const triggers = config.tables.map(tableName => {
    const cleanName = tableName.toLowerCase().replace(/[^a-z0-9_]/g, '_');
    return `-- Update timestamp trigger for ${cleanName}
CREATE TRIGGER update_${cleanName}_timestamp
  BEFORE UPDATE ON ${config.schema}.${cleanName}
  FOR EACH ROW EXECUTE FUNCTION ${config.schema}.update_timestamp();`;
  }).join('\n\n');
  
  return `-- Audit Triggers
${triggers}`;
}

/**
 * Generate permissions
 */
function generatePermissions(config: any): string {
  return `-- Permissions

-- Grant usage on schema
${generateGrantStatement('USAGE', `SCHEMA ${config.schema}`, config, true)}

-- Grant permissions on all tables
${generateGrantStatement('SELECT', `ALL TABLES IN SCHEMA ${config.schema}`, config, false)}
${generateGrantStatement('SELECT, INSERT, UPDATE, DELETE', `ALL TABLES IN SCHEMA ${config.schema}`, { anonRole: 'authenticated' }, false)}

-- Grant permissions on sequences
GRANT USAGE ON ALL SEQUENCES IN SCHEMA ${config.schema} TO authenticated;

-- Grant execute on functions
${generateGrantStatement('EXECUTE', `ALL FUNCTIONS IN SCHEMA ${config.schema}`, config, true)}

-- Set default privileges for future objects
ALTER DEFAULT PRIVILEGES IN SCHEMA ${config.schema}
  GRANT SELECT ON TABLES TO ${config.anonRole};

ALTER DEFAULT PRIVILEGES IN SCHEMA ${config.schema}
  GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA ${config.schema}
  GRANT USAGE ON SEQUENCES TO authenticated;`;
}

/**
 * Generate footer
 */
function generateFooter(): string {
  return `-- Schema generation complete
-- 
-- Next steps:
-- 1. Review and customize the generated schema
-- 2. Run: psql -d your_database -f schema.sql
-- 3. Configure PostgREST with these settings:
--    - db-schema = "api"
--    - db-anon-role = "web_anon"
--    - db-pre-request = "authenticator"
-- 4. Generate TypeScript types: pgrestify frontend types
--
-- Security checklist:
-- ✓ RLS enabled on all tables
-- ✓ Proper role separation (anon vs authenticated)
-- ✓ Secure default permissions
-- ✓ JWT integration ready
--
-- Generated by PGRestify - https://pgrestify.dev`;
}

/**
 * Display next steps
 */
function displayNextSteps(config: any) {
  logger.info(chalk.cyan('Next steps:'));
  logger.list([
    `Review the generated schema: ${config.output}`,
    `Apply to database: psql -d your_db -f ${config.output}`,
    'Configure PostgREST with the generated roles',
    'Generate TypeScript types: pgrestify frontend types',
    'Test your API endpoints'
  ]);
  
  logger.newLine();
  logger.info(chalk.yellow('🔒 Security Notes:'));
  logger.list([
    'RLS policies are enabled by default',
    'Review and customize policies for your use case',
    'Test authentication flows thoroughly',
    'Never expose sensitive data in public policies'
  ]);
}

/**
 * Generate schema using table-based folders
 */
async function generateSchemaInFolders(config: any) {
  const projectPath = process.cwd();
  const command = getCommandString();
  
  logger.info(chalk.blue('📁 Generating schema in table-based folders'));
  logger.newLine();
  
  // Generate schema setup (roles, extensions, etc.) in a special folder
  const setupSQL = generateSchemaSetup(config);
  await writeTableSQL(projectPath, '_schema_setup', SQL_FILE_TYPES.TABLE, setupSQL);
  logger.success('✅ Schema setup created in: sql/schemas/_schema_setup/table.sql');
  
  // Generate each table in its own folder
  for (const tableName of config.tables) {
    logger.info(`📋 Processing table: ${chalk.green(tableName)}`);
    
    // Create table folder
    await createTableFolderStructure(projectPath, tableName);
    
    // Generate table SQL
    const tableSQL = generateTable(tableName, config);
    await writeTableSQL(projectPath, tableName, SQL_FILE_TYPES.TABLE, tableSQL);
    
    // Generate table-specific RLS policies
    if (config.withRLS) {
      const rlsSQL = generateTableRLS(tableName, config);
      await writeTableSQL(projectPath, tableName, SQL_FILE_TYPES.RLS, rlsSQL);
    }
    
    // Generate table-specific triggers
    if (config.withTriggers) {
      const triggerSQL = generateTableTriggers(tableName, config);
      await writeTableSQL(projectPath, tableName, SQL_FILE_TYPES.TRIGGERS, triggerSQL);
    }
    
    logger.success(`  ✅ Generated: sql/schemas/${tableName}/`);
  }
  
  // Generate utility functions (shared across all tables)
  if (config.withFunctions) {
    const functionsSQL = generateUtilityFunctions(config);
    await fs.ensureDir(`${projectPath}/sql/functions`);
    const utilitiesPath = `${projectPath}/sql/functions/utilities.sql`;
    await fs.writeFile(utilitiesPath, functionsSQL);
    
    // Track the file write in hash service
    const hashService = getHashService(projectPath);
    await hashService.trackFileWrite(utilitiesPath, functionsSQL);
    
    logger.success('✅ Utility functions created in: sql/functions/utilities.sql');
  }
  
  logger.newLine();
  logger.success('🎉 Table-based schema generation complete!');
  
  displayTableFolderUsage(config);
}

/**
 * Generate schema as single file (legacy mode)
 */
async function generateSchemaAsSingleFile(config: any) {
  logger.info(chalk.blue('📄 Generating schema as single file (legacy mode)'));
  
  // Generate schema SQL
  const sql = generateCompleteSchema(config);
  
  // Write to file
  await fs.writeFile(config.output, sql);
  
  logger.success(`✅ Schema generated: ${config.output}`);
  logger.newLine();
  
  // Show next steps
  displayNextSteps(config);
}

/**
 * Generate schema setup (extensions, roles, etc.)
 */
function generateSchemaSetup(config: any): string {
  const parts = [
    generateHeader(config),
    generateExtensions(),
    generateSchemaSQL(config),
    generateRoles(config),
    generatePermissions(config),
  ];
  
  return parts.filter(Boolean).join('\n\n');
}

/**
 * Generate table-specific triggers
 */
function generateTableTriggers(tableName: string, config: any): string {
  const cleanName = tableName.toLowerCase().replace(/[^a-z0-9_]/g, '_');
  
  return `-- Update timestamp trigger for ${cleanName}
CREATE OR REPLACE FUNCTION ${config.schema}.update_${cleanName}_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_${cleanName}_timestamp
  BEFORE UPDATE ON ${config.schema}.${cleanName}
  FOR EACH ROW EXECUTE FUNCTION ${config.schema}.update_${cleanName}_timestamp();`;
}

/**
 * Check if project uses new table-folder structure
 */
async function checkForNewStructure(projectPath: string): Promise<boolean> {
  const schemasPath = `${projectPath}/sql/schemas`;
  
  if (!await fs.exists(schemasPath)) {
    return false;
  }
  
  const entries = await fs.readDir(schemasPath);
  
  // Look for directories (table folders)
  for (const entry of entries) {
    const fullPath = `${schemasPath}/${entry}`;
    const stats = await fs.stat(fullPath);
    if (stats.isDirectory()) {
      // Check if it has table.sql file (indicates new structure)
      const tableFile = `${fullPath}/table.sql`;
      if (await fs.exists(tableFile)) {
        return true;
      }
    }
  }
  
  return false;
}

/**
 * Display table folder usage instructions
 */
function displayTableFolderUsage(config: any) {
  logger.info(chalk.cyan('📁 Table-based Schema Structure:'));
  logger.newLine();
  
  logger.info('Generated files:');
  logger.list([
    'sql/schemas/_schema_setup/table.sql (roles, extensions)',
    ...config.tables.map(t => `sql/schemas/${t}/table.sql (table definition)`),
    ...config.withRLS ? config.tables.map(t => `sql/schemas/${t}/rls.sql (security policies)`) : [],
    ...config.withTriggers ? config.tables.map(t => `sql/schemas/${t}/triggers.sql (audit triggers)`) : [],
    ...config.withFunctions ? ['sql/functions/utilities.sql (utility functions)'] : []
  ]);
  
  logger.newLine();
  logger.info(chalk.cyan('🚀 Usage:'));
  logger.list([
    'Run migrations: pgrestify api migrate',
    'Add RLS policy: pgrestify api schema rls add <table>',
    'Generate more tables: pgrestify api schema generate --use-folders',
    'Migrate old projects: pgrestify api schema restructure'
  ]);
  
  logger.newLine();
  logger.info(chalk.yellow('💡 Benefits of table-based structure:'));
  logger.list([
    'Better organization - each table has its own folder',
    'Easier to maintain - find table-specific code quickly',
    'Scalable - add new tables without cluttering',
    'Collaborative - team members can work on different tables',
    'Version control friendly - smaller, focused files'
  ]);
}