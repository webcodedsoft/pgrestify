/**
 * @fileoverview Generate PostgREST functions from schema
 * 
 * Analyzes database schema and generates common PostgREST functions
 * like authentication, CRUD helpers, and custom endpoints.
 * 
 * @author PGRestify Team
 * @since 2.0.0
 */

import { Command } from 'commander';
import chalk from 'chalk';
import inquirer from 'inquirer';
import path from 'path';
import { logger } from '../../../utils/logger.js';
import { fs } from '../../../utils/fs.js';
import { getPostgRESTConfig } from '../../../utils/postgrest-config.js';

/**
 * Create functions generate command
 */
export function createGenerateCommand(): Command {
  const command = new Command('generate');
  
  command
    .description('Generate PostgREST functions from schema')
    .option('--schema <name>', 'Schema name')
    .option('--output <file>', 'Output file', './sql/functions/generated.sql')
    .option('--auth', 'Include authentication functions', true)
    .option('--crud', 'Include CRUD helper functions', true)
    .option('--utils', 'Include utility functions', true)
    .action(async (options) => {
      await generateFunctions(options);
    });
  
  return command;
}

/**
 * Generate PostgREST functions
 */
async function generateFunctions(options: any) {
  logger.info(chalk.cyan('⚡ Generating PostgREST Functions'));
  logger.newLine();
  
  const config = await collectFunctionConfig(options);
  const sql = await generateFunctionSQL(config);
  
  await fs.ensureDir(require('path').dirname(config.output));
  await fs.writeFile(config.output, sql);
  
  logger.success(`✅ Functions generated: ${config.output}`);
  await displayUsageInstructions(config);
}

/**
 * Collect function generation configuration
 */
async function collectFunctionConfig(options: any) {
  const { functionTypes } = await inquirer.prompt([
    {
      type: 'checkbox',
      name: 'functionTypes',
      message: 'Select function types to generate:',
      choices: [
        { name: 'Authentication functions (login, register, refresh)', value: 'auth', checked: options.auth },
        { name: 'CRUD helper functions (search, paginate, bulk operations)', value: 'crud', checked: options.crud },
        { name: 'Utility functions (timestamps, validation, formatting)', value: 'utils', checked: options.utils },
        { name: 'Custom endpoints (business logic functions)', value: 'custom', checked: false }
      ]
    }
  ]);
  
  return {
    schema: options.schema,
    output: options.output,
    functionTypes
  };
}

/**
 * Generate complete functions SQL
 */
async function generateFunctionSQL(config: any): Promise<string> {
  const parts = [
    generateHeader(config),
    config.functionTypes.includes('auth') ? await generateAuthFunctions(config) : '',
    config.functionTypes.includes('crud') ? generateCRUDFunctions(config) : '',
    config.functionTypes.includes('utils') ? generateUtilityFunctions(config) : '',
    config.functionTypes.includes('custom') ? generateCustomFunctions(config) : '',
    generatePermissions(config),
    generateFooter()
  ];
  
  return parts.filter(Boolean).join('\n\n');
}

/**
 * Generate SQL header
 */
function generateHeader(config: any): string {
  return `-- PostgREST Functions Generated by PGRestify
-- Generated: ${new Date().toISOString()}
-- Schema: ${config.schema}
-- 
-- These functions are optimized for PostgREST and provide
-- common patterns for authentication, CRUD operations, and utilities.
--
-- Usage: Apply this SQL to your database after the schema
-- Then access functions via POST requests to your PostgREST API`;
}

/**
 * Generate authentication functions
 */
async function generateAuthFunctions(config: any): Promise<string> {
  return `-- Authentication Functions

-- Register new user
CREATE OR REPLACE FUNCTION ${config.schema}.register(
  email TEXT,
  password TEXT,
  name TEXT DEFAULT NULL
)
RETURNS JSON AS $$
DECLARE
  user_id UUID;
  jwt_token TEXT;
BEGIN
  -- Validate email format
  IF email !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$' THEN
    RETURN json_build_object('error', 'Invalid email format');
  END IF;
  
  -- Check if user exists
  IF EXISTS (SELECT 1 FROM ${config.schema}.users WHERE users.email = register.email) THEN
    RETURN json_build_object('error', 'User already exists');
  END IF;
  
  -- Create user
  INSERT INTO ${config.schema}.users (email, name, password_hash)
  VALUES (register.email, register.name, crypt(register.password, gen_salt('bf')))
  RETURNING id INTO user_id;
  
  -- Generate JWT token
  jwt_token := sign(
    json_build_object(
      'sub', user_id::TEXT,
      'email', register.email,
      'role', 'authenticated',
      'exp', extract(epoch from now() + interval '7 days')
    ),
    current_setting('app.jwt_secret')
  );
  
  RETURN json_build_object(
    'token', jwt_token,
    'user', json_build_object(
      'id', user_id,
      'email', register.email,
      'name', register.name
    )
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Login user
CREATE OR REPLACE FUNCTION ${config.schema}.login(
  email TEXT,
  password TEXT
)
RETURNS JSON AS $$
DECLARE
  user_record RECORD;
  jwt_token TEXT;
BEGIN
  -- Find user and verify password
  SELECT id, email, name, password_hash, role
  INTO user_record
  FROM ${config.schema}.users
  WHERE users.email = login.email
    AND users.password_hash = crypt(login.password, users.password_hash);
  
  IF user_record IS NULL THEN
    RETURN json_build_object('error', 'Invalid credentials');
  END IF;
  
  -- Generate JWT token
  jwt_token := sign(
    json_build_object(
      'sub', user_record.id::TEXT,
      'email', user_record.email,
      'role', COALESCE(user_record.role, 'authenticated'),
      'exp', extract(epoch from now() + interval '7 days')
    ),
    current_setting('app.jwt_secret')
  );
  
  RETURN json_build_object(
    'token', jwt_token,
    'user', json_build_object(
      'id', user_record.id,
      'email', user_record.email,
      'name', user_record.name,
      'role', user_record.role
    )
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Refresh token
CREATE OR REPLACE FUNCTION ${config.schema}.refresh_token()
RETURNS JSON AS $$
DECLARE
  user_id UUID;
  user_record RECORD;
  jwt_token TEXT;
BEGIN
  -- Get user ID from current JWT
  user_id := current_setting('request.jwt.claims', true)::json->>'sub';
  
  IF user_id IS NULL THEN
    RETURN json_build_object('error', 'No valid token');
  END IF;
  
  -- Get user details
  SELECT id, email, name, role
  INTO user_record
  FROM ${config.schema}.users
  WHERE id = user_id;
  
  IF user_record IS NULL THEN
    RETURN json_build_object('error', 'User not found');
  END IF;
  
  -- Generate new token
  jwt_token := sign(
    json_build_object(
      'sub', user_record.id::TEXT,
      'email', user_record.email,
      'role', COALESCE(user_record.role, 'authenticated'),
      'exp', extract(epoch from now() + interval '7 days')
    ),
    current_setting('app.jwt_secret')
  );
  
  RETURN json_build_object(
    'token', jwt_token,
    'user', json_build_object(
      'id', user_record.id,
      'email', user_record.email,
      'name', user_record.name,
      'role', user_record.role
    )
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;`;
}

/**
 * Generate CRUD helper functions
 */
function generateCRUDFunctions(config: any): string {
  return `-- CRUD Helper Functions

-- Search function with pagination
CREATE OR REPLACE FUNCTION ${config.schema}.search(
  table_name TEXT,
  search_query TEXT DEFAULT NULL,
  limit_count INTEGER DEFAULT 20,
  offset_count INTEGER DEFAULT 0
)
RETURNS JSON AS $$
DECLARE
  query TEXT;
  result JSON;
BEGIN
  -- Basic search function template
  -- NOTE: This is a simplified example - customize for your tables
  
  query := format('
    SELECT json_agg(row_to_json(t)) 
    FROM (
      SELECT * FROM %I.%I 
      WHERE ($1 IS NULL OR name ILIKE $1)
      ORDER BY created_at DESC
      LIMIT $2 OFFSET $3
    ) t',
    '${config.schema}', table_name
  );
  
  EXECUTE query USING '%' || search_query || '%', limit_count, offset_count INTO result;
  
  RETURN COALESCE(result, '[]'::JSON);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Bulk upsert function
CREATE OR REPLACE FUNCTION ${config.schema}.bulk_upsert(
  table_name TEXT,
  data JSON
)
RETURNS JSON AS $$
DECLARE
  query TEXT;
  result JSON;
BEGIN
  -- This is a template - customize based on your table structure
  RETURN json_build_object('message', 'Bulk upsert completed', 'table', table_name);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;`;
}

/**
 * Generate utility functions
 */
function generateUtilityFunctions(config: any): string {
  return `-- Utility Functions

-- Get current user info
CREATE OR REPLACE FUNCTION ${config.schema}.current_user_info()
RETURNS JSON AS $$
DECLARE
  user_id UUID;
  user_record RECORD;
BEGIN
  user_id := (current_setting('request.jwt.claims', true)::json->>'sub')::UUID;
  
  IF user_id IS NULL THEN
    RETURN json_build_object('authenticated', false);
  END IF;
  
  SELECT id, email, name, role
  INTO user_record
  FROM ${config.schema}.users
  WHERE id = user_id;
  
  IF user_record IS NULL THEN
    RETURN json_build_object('authenticated', false);
  END IF;
  
  RETURN json_build_object(
    'authenticated', true,
    'user', json_build_object(
      'id', user_record.id,
      'email', user_record.email,
      'name', user_record.name,
      'role', user_record.role
    )
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Validate UUID format
CREATE OR REPLACE FUNCTION ${config.schema}.is_valid_uuid(uuid_text TEXT)
RETURNS BOOLEAN AS $$
BEGIN
  PERFORM uuid_text::UUID;
  RETURN TRUE;
EXCEPTION WHEN invalid_text_representation THEN
  RETURN FALSE;
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Generate slug from text
CREATE OR REPLACE FUNCTION ${config.schema}.generate_slug(input_text TEXT)
RETURNS TEXT AS $$
BEGIN
  RETURN lower(
    regexp_replace(
      regexp_replace(input_text, '[^a-zA-Z0-9\\s]', '', 'g'),
      '\\s+', '-', 'g'
    )
  );
END;
$$ LANGUAGE plpgsql IMMUTABLE;`;
}

/**
 * Generate custom function templates
 */
function generateCustomFunctions(config: any): string {
  return `-- Custom Function Templates

-- Example: Get user statistics
CREATE OR REPLACE FUNCTION ${config.schema}.user_stats(user_id UUID DEFAULT NULL)
RETURNS JSON AS $$
DECLARE
  target_user_id UUID;
  stats JSON;
BEGIN
  -- Use provided user_id or get from JWT
  target_user_id := COALESCE(
    user_id,
    (current_setting('request.jwt.claims', true)::json->>'sub')::UUID
  );
  
  -- Calculate user statistics
  SELECT json_build_object(
    'total_posts', COUNT(*)
  ) INTO stats
  FROM ${config.schema}.posts
  WHERE author_id = target_user_id;
  
  RETURN stats;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Example: Custom business logic function
CREATE OR REPLACE FUNCTION ${config.schema}.process_order(
  order_data JSON
)
RETURNS JSON AS $$
BEGIN
  -- Add your custom business logic here
  RETURN json_build_object('message', 'Order processed successfully');
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;`;
}

/**
 * Generate function permissions
 */
function generatePermissions(config: any): string {
  return `-- Function permissions are handled within each function type section above`;
}

/**
 * Generate footer
 */
function generateFooter(): string {
  return `-- Functions generation complete
--
-- Usage Examples:
--
-- Register user:
-- POST /rpc/register
-- {"email": "user@example.com", "password": "password", "name": "User Name"}
--
-- Login user:
-- POST /rpc/login  
-- {"email": "user@example.com", "password": "password"}
--
-- Search:
-- POST /rpc/search
-- {"table_name": "posts", "search_query": "hello", "limit_count": 10}
--
-- Get user info:
-- POST /rpc/current_user_info
-- (with Authorization: Bearer <token> header)
--
-- Generated by PGRestify - https://pgrestify.dev`;
}

/**
 * Display usage instructions
 */
async function displayUsageInstructions(config: any) {
  logger.newLine();
  logger.info(chalk.cyan('Usage:'));
  logger.list([
    `Apply functions: pgrestify api migrate (or manually: psql -d your_db -f ${config.output})`,
    'Access via POST /rpc/function_name',
    'Include JWT tokens for authenticated functions',
    'Test with curl or your frontend client'
  ]);
  
  logger.newLine();
  logger.info(chalk.yellow('Examples:'));
  
  const postgrestConfig = await getPostgRESTConfig();
  const serverPort = postgrestConfig.serverPort;
  
  logger.code(`# Register user
curl -X POST http://localhost:${serverPort}/rpc/register \\
  -H "Content-Type: application/json" \\
  -d '{"email": "user@test.com", "password": "password"}'

# Login user  
curl -X POST http://localhost:${serverPort}/rpc/login \\
  -H "Content-Type: application/json" \\
  -d '{"email": "user@test.com", "password": "password"}'`);
}