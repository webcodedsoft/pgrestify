# PGRestify Cursor Rules

You are an expert TypeScript developer working on PGRestify, a comprehensive PostgREST client library. Follow these rules and guidelines:

## Project Context

PGRestify is a type-safe, framework-agnostic TypeScript client library for PostgREST APIs. The goal is to create the de facto standard PostgREST client with excellent developer experience.

## Key Technologies
- TypeScript 5.0+ (strict mode)
- Vite/Rollup for bundling
- Vitest for testing
- pnpm for package management
- PostgREST API integration

## Code Style & Standards

### TypeScript Best Practices
- Always use strict TypeScript configuration
- Prefer `interface` for object shapes, `type` for unions/intersections
- Use generics extensively for type inference
- Implement proper type guards for runtime validation
- Always provide TSDoc comments for public APIs

```typescript
/**
 * Creates a type-safe query builder for the specified table
 * @param tableName - The name of the table to query
 * @returns A query builder instance with type inference
 */
function from<T extends Record<string, unknown>>(tableName: string): QueryBuilder<T>
```

### Naming Conventions
- Use PascalCase for types, interfaces, classes, and enums
- Use camelCase for functions, variables, and methods
- Use SCREAMING_SNAKE_CASE for constants
- Use kebab-case for file names

### File Organization
```
src/
├── core/                 # Framework-agnostic core
├── adapters/            # Framework-specific code
├── utils/               # Shared utilities
├── types/               # TypeScript definitions
└── __tests__/           # Test files
```

### PostgREST Query Operators
Always implement these operators with proper TypeScript inference:

```typescript
// Comparison
eq, neq, gt, gte, lt, lte

// Pattern matching  
like, ilike, match, imatch

// Logical operations
and, or, not

// Array operations
in, cs, cd

// Special operators
is, ov, sl, sr, nxl, nxr, adj
```

## API Design Principles

### 1. Type Safety First
```typescript
// Good: Full type inference
const users = await client
  .from<User>('users')
  .select('id', 'name', 'email') // TypeScript knows these are User keys
  .eq('active', true);           // TypeScript validates value type

// Bad: No type safety
const users = await client.query('users', { active: true });
```

### 2. Fluent Interface
```typescript
// Good: Method chaining with immutable operations
const query = client
  .from('users')
  .select('*')
  .eq('active', true)
  .gt('age', 18)
  .order('created_at', { ascending: false })
  .limit(10);

// Bad: Mutable operations
const query = client.from('users');
query.select('*');
query.where({ active: true });
```

### 3. Framework Agnostic Core
```typescript
// Core should never import framework-specific code
// Good:
import { HttpClient } from '../utils/http';

// Bad:
import React from 'react';
import { useEffect } from 'react';
```

## Error Handling Patterns

### Custom Error Types
```typescript
export class PostgRESTError extends Error {
  constructor(
    message: string,
    public statusCode: number,
    public code?: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'PostgRESTError';
  }
}

export class ValidationError extends PostgRESTError {
  constructor(message: string, public field: string, public value: unknown) {
    super(message, 400, 'VALIDATION_ERROR', { field, value });
  }
}
```

### Result Pattern
```typescript
type Result<T, E = PostgRESTError> = 
  | { success: true; data: T }
  | { success: false; error: E };

// Usage
async function fetchUser(id: number): Promise<Result<User>> {
  try {
    const user = await client.from('users').select('*').eq('id', id).single();
    return { success: true, data: user };
  } catch (error) {
    return { success: false, error: error as PostgRESTError };
  }
}
```

## Testing Requirements

### Test Structure
```typescript
describe('QueryBuilder', () => {
  describe('select method', () => {
    it('should build correct query string', () => {
      // Arrange
      const builder = new QueryBuilder('users');
      
      // Act
      const result = builder.select('id', 'name', 'email').build();
      
      // Assert
      expect(result.query).toBe('select=id,name,email');
    });

    it('should provide type safety', () => {
      // Type-level test using TypeScript's type system
      const builder = new QueryBuilder<User>('users');
      
      // This should compile
      builder.select('id', 'name', 'email');
      
      // This should cause TypeScript error (test with expectError)
      // builder.select('nonexistent_field');
    });
  });
});
```

### Performance Testing
```typescript
describe('Performance', () => {
  it('should handle large datasets efficiently', async () => {
    const startMemory = process.memoryUsage().heapUsed;
    
    // Simulate large dataset operations
    const users = await client
      .from('users')
      .select('*')
      .limit(10000);
    
    const endMemory = process.memoryUsage().heapUsed;
    const memoryIncrease = endMemory - startMemory;
    
    expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024); // 50MB limit
  });
});
```

## Framework Integration Patterns

### React Hooks
```typescript
export function useQuery<T>(
  table: string,
  queryFn?: (builder: QueryBuilder<T>) => QueryBuilder<T>
) {
  const [state, setState] = useState<{
    data: T[] | null;
    loading: boolean;
    error: PostgRESTError | null;
  }>({
    data: null,
    loading: true,
    error: null,
  });

  useEffect(() => {
    // Implementation
  }, [table, queryFn]);

  return state;
}
```

### TanStack Query Integration
```typescript
export function createPostgRESTQuery<T>() {
  return {
    queryKey: (table: string, query?: QueryBuilder<T>) => [table, query?.build()],
    queryFn: async ({ queryKey }: { queryKey: [string, string?] }) => {
      const [table, queryString] = queryKey;
      return client.from(table).raw(queryString).execute();
    },
  };
}
```

## Security Guidelines

### Input Validation
```typescript
// Always validate inputs
function validateTableName(name: string): void {
  if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name)) {
    throw new ValidationError('Invalid table name', 'tableName', name);
  }
}

// Sanitize user inputs
function sanitizeValue(value: unknown): string {
  if (typeof value === 'string') {
    return value.replace(/[^\w\s-]/gi, '');
  }
  return String(value);
}
```

### JWT Handling
```typescript
class AuthManager {
  private token: string | null = null;
  private refreshToken: string | null = null;

  setTokens(accessToken: string, refreshToken?: string) {
    this.token = accessToken;
    this.refreshToken = refreshToken;
    
    // Store securely (not localStorage for sensitive apps)
    if (typeof window !== 'undefined') {
      // Browser environment
      sessionStorage.setItem('pgrestify_token', accessToken);
    }
  }

  async getValidToken(): Promise<string | null> {
    if (!this.token) return null;
    
    // Check if token is expired and refresh if needed
    if (this.isTokenExpired(this.token) && this.refreshToken) {
      await this.refreshAccessToken();
    }
    
    return this.token;
  }
}
```

## Performance Optimization

### Bundle Size Optimization
```typescript
// Use tree-shakeable exports
export type { QueryBuilder, PostgRESTClient } from './core';
export { createClient } from './core/client';

// Avoid default exports for better tree-shaking
// Good:
export { ReactAdapter } from './react-adapter';

// Bad:
export default ReactAdapter;
```

### Caching Strategy
```typescript
class QueryCache {
  private cache = new Map<string, { data: unknown; timestamp: number }>();
  private readonly TTL = 5 * 60 * 1000; // 5 minutes

  get<T>(key: string): T | null {
    const entry = this.cache.get(key);
    if (!entry) return null;
    
    if (Date.now() - entry.timestamp > this.TTL) {
      this.cache.delete(key);
      return null;
    }
    
    return entry.data as T;
  }

  set<T>(key: string, data: T): void {
    this.cache.set(key, { data, timestamp: Date.now() });
  }
}
```

## Common Patterns

### Builder Pattern Implementation
```typescript
export class QueryBuilder<T = Record<string, unknown>> {
  private queryParts: {
    select?: string;
    where?: string[];
    order?: string;
    limit?: number;
    offset?: number;
  } = {};

  select<K extends keyof T>(...columns: K[]): QueryBuilder<Pick<T, K>> {
    const newBuilder = new QueryBuilder<Pick<T, K>>();
    newBuilder.queryParts = { ...this.queryParts };
    newBuilder.queryParts.select = columns.join(',');
    return newBuilder;
  }

  eq<K extends keyof T>(column: K, value: T[K]): QueryBuilder<T> {
    const newBuilder = new QueryBuilder<T>();
    newBuilder.queryParts = { ...this.queryParts };
    newBuilder.queryParts.where = [
      ...(this.queryParts.where || []),
      `${String(column)}=eq.${value}`
    ];
    return newBuilder;
  }
}
```

## Documentation Standards

### JSDoc Format
```typescript
/**
 * Executes a query against the PostgREST API
 * 
 * @example
 * ```typescript
 * const users = await client
 *   .from<User>('users')
 *   .select('id', 'name')
 *   .eq('active', true);
 * ```
 * 
 * @param options - Query execution options
 * @returns Promise that resolves to query results
 * @throws {PostgRESTError} When the query fails
 * @throws {ValidationError} When input validation fails
 * 
 * @public
 */
async execute<TResult = T>(options?: ExecuteOptions): Promise<TResult[]>
```

## Testing Commands
- `pnpm test` - Run all tests
- `pnpm test:watch` - Run tests in watch mode
- `pnpm test:coverage` - Run tests with coverage report
- `pnpm typecheck` - Check TypeScript types
- `pnpm lint` - Run ESLint
- `pnpm build` - Build the library

## Remember
- Always prioritize type safety and developer experience
- Test everything thoroughly including edge cases
- Keep bundle size minimal (< 15KB gzipped for core)
- Document all public APIs with examples
- Follow PostgREST conventions and best practices
- Consider performance implications of every feature
- Maintain backward compatibility when possible

When implementing new features, always ask:
1. Is this type-safe?
2. Does this work across all supported frameworks?
3. Are there edge cases I haven't considered?
4. Is the API intuitive for developers?
5. Does this maintain our performance requirements?